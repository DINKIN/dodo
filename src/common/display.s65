                  .setcpu "6502"

                  .include "zeropage.inc65"

                  SSD1305_COMMAND = $4800
                  SSD1305_DATA = $4801

                  SSD1305_SETLOWCOLUMN = $00
                  SSD1305_SETHIGHCOLUMN = $10
                  SSD1305_MEMORYMODE = $20
                  SSD1305_SETCOLADDR = $21
                  SSD1305_SETPAGEADDR = $22
                  SSD1305_SETSTARTLINE = $40

                  SSD1305_SETCONTRAST = $81
                  SSD1305_SETBRIGHTNESS = $82

                  SSD1305_SETLUT = $91

                  SSD1305_SEGREMAP = $A0
                  SSD1305_DISPLAYALLON_RESUME = $A4
                  SSD1305_DISPLAYALLON = $A5
                  SSD1305_NORMALDISPLAY = $A6
                  SSD1305_INVERTDISPLAY = $A7
                  SSD1305_SETMULTIPLEX = $A8
                  SSD1305_DISPLAYDIM = $AC
                  SSD1305_MASTERCONFIG = $AD
                  SSD1305_DISPLAYOFF = $AE
                  SSD1305_DISPLAYON = $AF

                  SSD1305_SETPAGESTART = $B0

                  SSD1305_COMSCANINC = $C0
                  SSD1305_COMSCANDEC = $C8
                  SSD1305_SETDISPLAYOFFSET = $D3
                  SSD1305_SETDISPLAYCLOCKDIV = $D5
                  SSD1305_SETAREACOLOR = $D8
                  SSD1305_SETPRECHARGE = $D9
                  SSD1305_SETCOMPINS = $DA
                  SSD1305_SETVCOMLEVEL = $DB

                  .export ssd1305_init
                  .export _display      
                  .export _draw_sprite
                  .export _set_pixel
                  .export _clear_sprite

                  .import popax 
                  .import popa           

                  .macro dc cmd
                    lda #cmd
                    sta SSD1305_COMMAND
                  .endmacro

                  .macro dco cmd, offset
                    lda #offset
                    sta R1
                    lda #cmd
                    adc R1
                    sta SSD1305_COMMAND
                  .endmacro

                  .code
ssd1305_init:
                  dc SSD1305_DISPLAYOFF              ; $AE
                  dco SSD1305_SETLOWCOLUMN, $4       ; low col = 0  (This doesn't seem right)
                  dco SSD1305_SETHIGHCOLUMN, $4      ; hi col = 0
                  dco SSD1305_SETSTARTLINE, $0       ; line #0
                  dc $2E                             ; Stop scrolling
                  dc SSD1305_SETCONTRAST             ; $81
                  dc $32
                  dc SSD1305_SETBRIGHTNESS           ; $82
                  dc $80
                  dco SSD1305_SEGREMAP, $1
                  dc SSD1305_NORMALDISPLAY           ; $A6
                  dc SSD1305_SETMULTIPLEX            ; $A8
                  dc $3F                             ; 1/64
                  dc SSD1305_MASTERCONFIG
                  dc $8e                             ; external vcc supply
                  dc SSD1305_COMSCANDEC
                  dc SSD1305_SETDISPLAYOFFSET        ; $D3
                  dc $40
                  dc SSD1305_SETDISPLAYCLOCKDIV      ; $D5
                  dc $f0
                  dc SSD1305_SETAREACOLOR
                  dc $05
                  dc SSD1305_SETPRECHARGE            ; $d9
                  dc $F1
                  dc SSD1305_SETCOMPINS              ; $DA
                  dc $12
                  dc SSD1305_SETLUT
                  dc $3F
                  dc $3F
                  dc $3F
                  dc $3F
                  dc SSD1305_DISPLAYON
                  rts


;void setPixel(unsigned char x, unsigned char y, unsigned char c)
 _set_pixel:
                  sta tmp1          ; c
                  jsr popa
                  sta tmp2          ; y
                  jsr popa
                  sta tmp3          ; x

                  lda tmp2          ; calculate %
                  and #$07
                  sta tmp4
                  lda tmp2
                  lsr
                  lsr
                  lsr
                  sta tmp5          ; Page

                  lda #$00          ; pointer to vmem
                  sta ptr1
                  lda #$3C
                  sta ptr1+1

                  ; Calculate offset into vmem based on page
                  lda tmp5          ; Load page into a
                  jsr multiply_128  ; a/x = page * 128
                  adc ptr1
                  sta ptr1
                  txa
                  adc ptr1+1
                  sta ptr1+1
                  clc

                  lda #<shift_table
                  sta ptr2
                  lda #>shift_table
                  sta ptr2+1

                  lda tmp1
                  beq @clear

                  ldy tmp4
                  lda (ptr2), y
                  ldy tmp3
                  ora (ptr1), y
                  sta (ptr1), y
                  rts

@clear:
                  ldy tmp4
                  lda (ptr2), y
                  eor #$ff
                  ldy tmp3
                  and (ptr1), y
                  sta (ptr1), y
                  rts       

; void clearSprite(unsigned char x, unsigned char y, unsigned char w, unsigned char h)
_clear_sprite:
                  sta tmp1          ; h
                  jsr popa
                  sta tmp2          ; w
                  jsr popa
                  sta tmp3          ; y
                  jsr popa
                  sta tmp4          ; x

                  lda tmp3
                  lsr
                  lsr
                  lsr
                  sta tmp5          ; Page

                  lda tmp3
                  and #$07
                  beq @load

                  clc
                  lda tmp1
                  adc #8
                  sta tmp1

@load:
                  lda #$00          ; pointer to vmem
                  sta ptr1
                  lda #$3C
                  sta ptr1+1

                  ; Calculate offset into vmem based on page
                  lda tmp5
                  jsr multiply_128  ; a/x = page * 128
                  adc ptr1
                  sta ptr1
                  txa
                  adc ptr1+1
                  sta ptr1+1
                  clc

                  lda tmp4          ; add x to ptr1
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  ldy tmp2          ; Load width into y, will decrement to 0     
                  dey               ; start at w - 1

@start:           lda #0
@next:            sta (ptr1), y
                  dey
                  bne @next
                  sta (ptr1), y

                  lda tmp1  
                  sec                
                  sbc #8
                  beq @done    ; If h now down to 0, done
                  sta tmp1

                  clc
                  lda #128          ; Load up next stripe
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  ldy tmp2
                  dey

                  jmp @start
@done:
                  rts                         


; drawing to #3C00
;void drawSprite(unsigned char* sprite, unsigned char x, unsigned char y, unsigned char w, unsigned char h, unsigned char flip)
_draw_sprite:                  
                  sta tmp7          ; flip

                  jsr popa  
                  sta tmp1          ; h
                  jsr popa
                  sta tmp2          ; w
                  jsr popa
                  sta tmp3          ; y
                  jsr popa
                  sta tmp4          ; x
                  jsr popax
                  sta ptr2          ; sprite
                  stx ptr2+1


                  lda tmp3
                  and #$07          ; calculate %
                  sta tmp5
                  lda tmp3
                  lsr               ; divide by 8
                  lsr
                  lsr
                  sta tmp6          ; Page

                  lda #$00          ; pointer to vmem
                  sta ptr1
                  lda #$3C
                  sta ptr1+1

                  ; Calculate offset into vmem based on page
                  lda tmp6          ; Load page into a
                  jsr multiply_128  ; a/x = page * 128
                  adc ptr1
                  sta ptr1
                  txa
                  adc ptr1+1
                  sta ptr1+1
                  clc

                  lda tmp4          ; add x to ptr1
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  lda tmp5
                  beq @fast   
                  jmp @complex                

                  ; Fast case
@fast:            
                  ldy tmp2          ; Load width into y, will decrement to 0     
                  dey               ; start at w - 1
@fast_stripe:
                  ldx #0
                  lda tmp7
                  bne @fast_byte_flip

@fast_byte:
                  lda (ptr1), y
                  ora (ptr2), y
                  sta (ptr1), y
                  dey
                  bne @fast_byte
                  lda (ptr1), y      ; Last byte
                  ora (ptr2), y
                  sta (ptr1), y
                  jmp @fast_next_stripe
@fast_byte_flip:
                  tya
                  pha
                  txa                  
                  tay
                  inx
                  lda (ptr2), y
                  sta tmp8
                  pla
                  tay
                  lda (ptr1), y
                  ora tmp8
                  sta (ptr1), y  
                  dey                
                  bne @fast_byte_flip
                  txa               ; Last byte
                  tay
                  lda (ptr2), y
                  sta tmp8
                  ldy #0
                  lda (ptr1), y
                  ora tmp8
                  sta (ptr1), y

@fast_next_stripe:
                  lda tmp1  
                  sec                
                  sbc #8
                  beq @done_fast    ; If h now down to 0, done
                  sta tmp1

                  clc
                  lda #128          ; Load up next stripe
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  clc
                  lda tmp2
                  adc ptr2
                  sta ptr2
                  lda #0
                  adc ptr2+1
                  sta ptr2+1

                  ldy tmp2
                  dey

                  jmp @fast_stripe

@done_fast:       jmp @done

@complex:          
                  sec
                  lda #8
                  sbc tmp5
                  sta tmp8          ; 8 - (y%8)

                  ldy tmp2          ; Load width into y, will decrement to 0     
                  dey               ; start at w - 1


@complex_stripe:

                  clc               ; Store next row in ptr3
                  lda #128
                  adc ptr1
                  sta ptr3
                  lda #0
                  adc ptr1+1
                  sta ptr3+1

                  ldx #0
                  lda tmp7
                  bne @complex_byte_flip  ; TODO: Jump to complex flip

@complex_byte:                  
                  lda (ptr2), y     ; shift << into current row
                  ldx tmp5
@next_asl:        asl
                  dex
                  bne @next_asl
                  ora (ptr1), y
                  sta (ptr1), y

                  lda (ptr2), y     ; shift >> into next row
                  ldx tmp8
@next_lsr:        lsr
                  dex
                  bne @next_lsr
                  ora (ptr3), y
                  sta (ptr3), y
                  dey
                  bne @complex_byte

                  lda (ptr2), y     ; Last byte
                  ldx tmp5
@next_asl_last:   asl
                  dex
                  bne @next_asl_last
                  ora (ptr1), y
                  sta (ptr1), y

                  lda (ptr2), y
                  ldx tmp8
@next_lsr_last:   lsr
                  dex
                  bne @next_lsr_last
                  ora (ptr3), y
                  sta (ptr3), y
                  jmp @complex_next_stripe

@complex_byte_flip:
                  tya
                  pha
                  txa
                  tay
                  inx
                  lda (ptr2), y
                  sta tmp3         ; Reuse tmp3, y not needed anymore
                  pla
                  tay

                  txa
                  pha
                  lda tmp3
                  ldx tmp5
@next_asl_flip:   asl
                  dex
                  bne @next_asl_flip
                  ora (ptr1), y
                  sta (ptr1), y

                  lda tmp3
                  ldx tmp8
@next_lsr_flip:   lsr
                  dex
                  bne @next_lsr_flip
                  ora (ptr3), y
                  sta (ptr3), y
                  pla
                  tax
                  dey
                  bne @complex_byte_flip
                  
                  txa            ; Last byte
                  tay
                  lda (ptr2), y
                  sta tmp3

                  ldy #0
                  ldx tmp5
@next_asl_flip_last:
                  asl
                  dex
                  bne @next_asl_flip_last
                  ora (ptr1), y
                  sta (ptr1), y

                  lda tmp3
                  ldx tmp8
@next_lsr_flip_last:
                  lsr
                  dex
                  bne @next_lsr_flip_last
                  ora (ptr3), y
                  sta (ptr3), y

@complex_next_stripe:
                  lda tmp1  
                  sec                
                  sbc #8
                  beq @done         ; If h now down to 0, done
                  sta tmp1

                  clc
                  lda #128          ; Load up next stripe
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  clc
                  lda tmp2
                  adc ptr2
                  sta ptr2
                  lda #0
                  adc ptr2+1
                  sta ptr2+1

                  ldy tmp2
                  dey

                  jmp @complex_stripe       
@done:
                  rts

; multiply 8-bit number in a and store results in a/x as 16-bit
multiply_128:
                  ldy tmp1    ; cache tmp1 in y
                  ldx #0      ; store 0 in tmp1, a already populated
                  stx tmp1
                  asl a       ; 2
                  rol tmp1
                  asl a       ; 4
                  rol tmp1
                  asl a       ; 8
                  rol tmp1
                  asl a       ; 16
                  rol tmp1
                  asl a       ; 32
                  rol tmp1
                  asl a       ; 64
                  rol tmp1
                  asl a       ; 128
                  rol tmp1
                  ldx tmp1            
                  sty tmp1
                  clc
                  rts

; Drawn from $3C00
_display:              
                  clc
                  clv   
                  lda #$00
                  sta R0
                  lda #$3C
                  sta R0 + 1

                  ldx #$0
                  ldy #$0

@next_page_group: lda #SSD1305_SETPAGESTART  ; even pages (0, 2, 4, 6)
                  stx R1
                  adc R1
                  sta SSD1305_COMMAND       ; Set Page
                  dc $00
                  dc $10

                  ; loop y < 128
@byte_loop1:      lda (R0), y
                  sta SSD1305_DATA
                  iny
                  bpl @byte_loop1
                  
                  ; odd pages (1, 3, 5, 7)
                  inx
                  lda #SSD1305_SETPAGESTART
                  stx R1
                  adc R1
                  sta SSD1305_COMMAND       ; Set Page
                  dc $00
                  dc $10
                  ; loop y < 256
@byte_loop2:      lda (R0), y
                  sta SSD1305_DATA
                  iny
                  bne @byte_loop2
                  inc R0 + 1                ; update pointer to the next block of 256
                  inx
                  stx R1
                  lda #8
                  bit R1
                  beq @next_page_group
                  rts

shift_table:               .byte 1, 2, 4, 8, 16, 32, 64, 128