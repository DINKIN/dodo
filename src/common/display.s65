                  .setcpu "6502"

                  .include "zeropage.inc65"
                  .include "api.inc65"

                  SSD1305_COMMAND = $4800
                  SSD1305_DATA = $4801

                  SSD1305_SETLOWCOLUMN = $00
                  SSD1305_SETHIGHCOLUMN = $10
                  SSD1305_MEMORYMODE = $20
                  SSD1305_SETCOLADDR = $21
                  SSD1305_SETPAGEADDR = $22
                  SSD1305_SETSTARTLINE = $40

                  SSD1305_SETCONTRAST = $81
                  SSD1305_SETBRIGHTNESS = $82

                  SSD1305_SETLUT = $91

                  SSD1305_SEGREMAP = $A0
                  SSD1305_DISPLAYALLON_RESUME = $A4
                  SSD1305_DISPLAYALLON = $A5
                  SSD1305_NORMALDISPLAY = $A6
                  SSD1305_INVERTDISPLAY = $A7
                  SSD1305_SETMULTIPLEX = $A8
                  SSD1305_DISPLAYDIM = $AC
                  SSD1305_MASTERCONFIG = $AD
                  SSD1305_DISPLAYOFF = $AE
                  SSD1305_DISPLAYON = $AF

                  SSD1305_SETPAGESTART = $B0

                  SSD1305_COMSCANINC = $C0
                  SSD1305_COMSCANDEC = $C8
                  SSD1305_SETDISPLAYOFFSET = $D3
                  SSD1305_SETDISPLAYCLOCKDIV = $D5
                  SSD1305_SETAREACOLOR = $D8
                  SSD1305_SETPRECHARGE = $D9
                  SSD1305_SETCOMPINS = $DA
                  SSD1305_SETVCOMLEVEL = $DB

                  .export ssd1305_init
                  .export display      
                  .export draw_sprite
                  .export set_pixel
                  .export clear_sprite  
                  .export draw_line        

                  .macro dc cmd
                    lda #cmd
                    sta SSD1305_COMMAND
                  .endmacro

                  .macro dco cmd, offset
                    lda #offset
                    sta R1
                    lda #cmd
                    adc R1
                    sta SSD1305_COMMAND
                  .endmacro

                  .code
ssd1305_init:
                  dc SSD1305_DISPLAYOFF              ; $AE
                  dco SSD1305_SETLOWCOLUMN, $4       ; low col = 0  (This doesn't seem right)
                  dco SSD1305_SETHIGHCOLUMN, $4      ; hi col = 0
                  dco SSD1305_SETSTARTLINE, $0       ; line #0
                  dc $2E                             ; Stop scrolling
                  dc SSD1305_SETCONTRAST             ; $81
                  dc $32
                  dc SSD1305_SETBRIGHTNESS           ; $82
                  dc $80
                  dco SSD1305_SEGREMAP, $1
                  dc SSD1305_NORMALDISPLAY           ; $A6
                  dc SSD1305_SETMULTIPLEX            ; $A8
                  dc $3F                             ; 1/64
                  dc SSD1305_MASTERCONFIG
                  dc $8e                             ; external vcc supply
                  dc SSD1305_COMSCANDEC
                  dc SSD1305_SETDISPLAYOFFSET        ; $D3
                  dc $40
                  dc SSD1305_SETDISPLAYCLOCKDIV      ; $D5
                  dc $f0
                  dc SSD1305_SETAREACOLOR
                  dc $05
                  dc SSD1305_SETPRECHARGE            ; $d9
                  dc $F1
                  dc SSD1305_SETCOMPINS              ; $DA
                  dc $12
                  dc SSD1305_SETLUT
                  dc $3F
                  dc $3F
                  dc $3F
                  dc $3F
                  dc SSD1305_DISPLAYON
                  rts


;void setPixel(unsigned char x, unsigned char y, unsigned char c)
 set_pixel:
                  sta tmp5          ; c
                  jsr tramp_popa
                  sta tmp1          ; y
                  jsr tramp_popa
                  sta tmp2          ; x
set_pixel_noargs:                   ; alternate entry point

                  lda tmp1          ; calculate %
                  and #$07
                  sta tmp4
                  lda tmp1
                  lsr
                  lsr
                  lsr
                  sta tmp3          ; Page

                  lda #$00          ; pointer to vmem
                  sta ptr1
                  lda #$3C
                  sta ptr1+1

                  ; Calculate offset into vmem based on page
                  lda tmp3          ; Load page into a
                  jsr multiply_128  ; a/x = page * 128
                  adc ptr1
                  sta ptr1
                  txa
                  adc ptr1+1
                  sta ptr1+1
                  clc

                  lda #<shift_table
                  sta ptr2
                  lda #>shift_table
                  sta ptr2+1

                  lda tmp5
                  beq @clear

                  ldy tmp4
                  lda (ptr2), y
                  ldy tmp2
                  ora (ptr1), y
                  sta (ptr1), y
                  rts

@clear:
                  ldy tmp4
                  lda (ptr2), y
                  eor #$ff
                  ldy tmp2
                  and (ptr1), y
                  sta (ptr1), y
                  rts       

; void clearSprite(unsigned char x, unsigned char y, unsigned char w, unsigned char h)
clear_sprite:
                  sta tmp1          ; h
                  jsr tramp_popa
                  sta tmp2          ; w
                  jsr tramp_popa
                  sta tmp3          ; y
                  jsr tramp_popa
                  sta tmp4          ; x

                  lda tmp3
                  lsr
                  lsr
                  lsr
                  sta tmp5          ; Page

                  lda tmp3
                  and #$07
                  beq @load

                  clc
                  lda tmp1
                  adc #8
                  sta tmp1

@load:
                  lda #$00          ; pointer to vmem
                  sta ptr1
                  lda #$3C
                  sta ptr1+1

                  ; Calculate offset into vmem based on page
                  lda tmp5
                  jsr multiply_128  ; a/x = page * 128
                  adc ptr1
                  sta ptr1
                  txa
                  adc ptr1+1
                  sta ptr1+1
                  clc

                  lda tmp4          ; add x to ptr1
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  ldy tmp2          ; Load width into y, will decrement to 0     
                  dey               ; start at w - 1

@start:           lda #0
@next:            sta (ptr1), y
                  dey
                  bne @next
                  sta (ptr1), y

                  lda tmp1  
                  sec                
                  sbc #8
                  beq @done    ; If h now down to 0, done
                  sta tmp1

                  clc
                  lda #128          ; Load up next stripe
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  ldy tmp2
                  dey

                  jmp @start
@done:
                  rts                         


; drawing to #3C00
; void drawSprite(unsigned char* sprite, unsigned char x, unsigned char y, unsigned char w, unsigned char h, unsigned char flip)
draw_sprite:                  
                  sta tmp7          ; flip
                  jsr tramp_popa  
                  sta tmp1          ; h
                  jsr tramp_popa
                  sta tmp2          ; w
                  jsr tramp_popa
                  sta tmp3          ; y
                  jsr tramp_popa
                  sta tmp4          ; x
                  jsr tramp_popax
                  sta ptr2          ; sprite
                  stx ptr2+1


                  lda tmp3
                  and #$07          ; calculate %
                  sta tmp5
                  lda tmp3
                  lsr               ; divide by 8
                  lsr
                  lsr
                  sta tmp6          ; Page

                  lda #$00          ; pointer to vmem
                  sta ptr1
                  lda #$3C
                  sta ptr1+1

                  ; Calculate offset into vmem based on page
                  lda tmp6          ; Load page into a
                  jsr multiply_128  ; a/x = page * 128
                  adc ptr1
                  sta ptr1
                  txa
                  adc ptr1+1
                  sta ptr1+1
                  clc

                  lda tmp4          ; add x to ptr1
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  lda tmp5
                  beq @fast   
                  jmp @complex                

                  ; Fast case
@fast:            
                  ldy tmp2          ; Load width into y, will decrement to 0     
                  dey               ; start at w - 1
@fast_stripe:
                  ldx #0
                  lda tmp7
                  bne @fast_byte_flip

@fast_byte:
                  lda (ptr1), y
                  ora (ptr2), y
                  sta (ptr1), y
                  dey
                  bne @fast_byte
                  lda (ptr1), y      ; Last byte
                  ora (ptr2), y
                  sta (ptr1), y
                  jmp @fast_next_stripe
@fast_byte_flip:
                  tya
                  pha
                  txa                  
                  tay
                  inx
                  lda (ptr2), y
                  sta tmp8
                  pla
                  tay
                  lda (ptr1), y
                  ora tmp8
                  sta (ptr1), y  
                  dey                
                  bne @fast_byte_flip
                  txa               ; Last byte
                  tay
                  lda (ptr2), y
                  sta tmp8
                  ldy #0
                  lda (ptr1), y
                  ora tmp8
                  sta (ptr1), y

@fast_next_stripe:
                  lda tmp1  
                  sec                
                  sbc #8
                  beq @done_fast    ; If h now down to 0, done
                  sta tmp1

                  clc
                  lda #128          ; Load up next stripe
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  clc
                  lda tmp2
                  adc ptr2
                  sta ptr2
                  lda #0
                  adc ptr2+1
                  sta ptr2+1

                  ldy tmp2
                  dey

                  jmp @fast_stripe

@done_fast:       jmp @done

@complex:          
                  sec
                  lda #8
                  sbc tmp5
                  sta tmp8          ; 8 - (y%8)

                  ldy tmp2          ; Load width into y, will decrement to 0     
                  dey               ; start at w - 1


@complex_stripe:

                  clc               ; Store next row in ptr3
                  lda #128
                  adc ptr1
                  sta ptr3
                  lda #0
                  adc ptr1+1
                  sta ptr3+1

                  ldx #0
                  lda tmp7
                  bne @complex_byte_flip  ; TODO: Jump to complex flip

@complex_byte:                  
                  lda (ptr2), y     ; shift << into current row
                  ldx tmp5
@next_asl:        asl
                  dex
                  bne @next_asl
                  ora (ptr1), y
                  sta (ptr1), y

                  lda (ptr2), y     ; shift >> into next row
                  ldx tmp8
@next_lsr:        lsr
                  dex
                  bne @next_lsr
                  ora (ptr3), y
                  sta (ptr3), y
                  dey
                  bne @complex_byte

                  lda (ptr2), y     ; Last byte
                  ldx tmp5
@next_asl_last:   asl
                  dex
                  bne @next_asl_last
                  ora (ptr1), y
                  sta (ptr1), y

                  lda (ptr2), y
                  ldx tmp8
@next_lsr_last:   lsr
                  dex
                  bne @next_lsr_last
                  ora (ptr3), y
                  sta (ptr3), y
                  jmp @complex_next_stripe

@complex_byte_flip:
                  tya
                  pha
                  txa
                  tay
                  inx
                  lda (ptr2), y
                  sta tmp3         ; Reuse tmp3, y not needed anymore
                  pla
                  tay

                  txa
                  pha
                  lda tmp3
                  ldx tmp5
@next_asl_flip:   asl
                  dex
                  bne @next_asl_flip
                  ora (ptr1), y
                  sta (ptr1), y

                  lda tmp3
                  ldx tmp8
@next_lsr_flip:   lsr
                  dex
                  bne @next_lsr_flip
                  ora (ptr3), y
                  sta (ptr3), y
                  pla
                  tax
                  dey
                  bne @complex_byte_flip
                  
                  txa            ; Last byte
                  tay
                  lda (ptr2), y
                  sta tmp3

                  ldy #0
                  ldx tmp5
@next_asl_flip_last:
                  asl
                  dex
                  bne @next_asl_flip_last
                  ora (ptr1), y
                  sta (ptr1), y

                  lda tmp3
                  ldx tmp8
@next_lsr_flip_last:
                  lsr
                  dex
                  bne @next_lsr_flip_last
                  ora (ptr3), y
                  sta (ptr3), y

@complex_next_stripe:
                  lda tmp1  
                  sec                
                  sbc #8
                  beq @done         ; If h now down to 0, done
                  sta tmp1

                  clc
                  lda #128          ; Load up next stripe
                  adc ptr1
                  sta ptr1
                  lda #0
                  adc ptr1+1
                  sta ptr1+1

                  clc
                  lda tmp2
                  adc ptr2
                  sta ptr2
                  lda #0
                  adc ptr2+1
                  sta ptr2+1

                  ldy tmp2
                  dey

                  jmp @complex_stripe       
@done:
                  rts

; multiply 8-bit number in a and store results in a/x as 16-bit
multiply_128:
                  ldy tmp1    ; cache tmp1 in y
                  ldx #0      ; store 0 in tmp1, a already populated
                  stx tmp1
                  asl a       ; 2
                  rol tmp1
                  asl a       ; 4
                  rol tmp1
                  asl a       ; 8
                  rol tmp1
                  asl a       ; 16
                  rol tmp1
                  asl a       ; 32
                  rol tmp1
                  asl a       ; 64
                  rol tmp1
                  asl a       ; 128
                  rol tmp1
                  ldx tmp1            
                  sty tmp1
                  clc
                  rts

; void drawLine(unsigned char x0, unsigned char y0, unsigned char x1, unsigned char y1, unsigned char c) {
draw_line:
                  ldy #0

                  sta tmp5          ; c
                  jsr tramp_popa
                  sta tmp4          ; y1
                  jsr tramp_popa
                  sta tmp3          ; x1
                  jsr tramp_popa
                  sta tmp2          ; y0
                  jsr tramp_popa
                  sta tmp1          ; x0

                  ; unsigned char steep = abs((signed char)y1-(signed char)y0) > abs((signed char)x1-(signed char)x0);
                  lda tmp4
                  sec
                  sbc tmp2
                  jsr abs
                  sta tmp6

                  lda tmp3
                  sec
                  sbc tmp1
                  jsr abs
                  sta tmp7

                  cmp tmp6
                  bcs @noswap

                  ldy #1            ; store steep in y

                  ; if steep swap  x0, y0 and x1, y1
                  lda tmp1
                  ldx tmp2
                  sta tmp2
                  stx tmp1

                  lda tmp3
                  ldx tmp4
                  sta tmp4
                  stx tmp3
@noswap:
                  ; if x0 > x1 swap x0, x1 and y0, y1
                  lda tmp3
                  cmp tmp1
                  bcs @right

                  lda tmp1
                  ldx tmp3
                  sta tmp3
                  stx tmp1

                  lda tmp2
                  ldx tmp4
                  sta tmp4
                  stx tmp2

@right:

                  ; dx = x1-x0;
                  ; dy = (unsigned char)abs((signed char)y1-(signed char)y0);

                  lda tmp3
                  sec
                  sbc tmp1
                  sta tmp6    ; dx = tmp6

                  lda tmp4
                  sec
                  sbc tmp2
                  jsr abs
                  sta tmp7    ; dy = tmp7

                  ; err = dx/2;

                  lda tmp6
                  lsr
                  sta tmp8    ; err = tmp8

                  ;if (y0 < y1) {
                  ;      ystep = 1;
                  ;} else {
                  ;      ystep = -1;
                  ;}

                  lda tmp2
                  cmp tmp4
                  bcs @neg
                  lda #1
                  sta tmp4    ; ystep = tmp4 = 1 (at this point y1 no longer needed so reuse tmp4)
                  jmp @next
@neg:
                  lda #$ff    ; ystep = tmp4 = -1
                  sta tmp4            
@next:

                  tya
                  bne @steep
@shallow:

                  
                  jmp @done
@steep:

                  ;for (; x0<=x1; ++x0) {
                  ;      SET_PIXEL(y0, x0, c);

                  ;      err -= dy;
                  ;      if (err < 0) {
                  ;            y0 += ystep;
                  ;            err += dx;
                  ;      }
                  ;}

                  lda tmp3
                  cmp tmp1
                  bcc @done

                  
                  lda tmp3          ; Save tmp3, and tmp4 because they will be modified by set pixel
                  pha
                  lda tmp4
                  pha

                  jsr set_pixel_noargs    ; x0, y0 and c are already in correct memory locations for set_pixel

                  pla
                  sta tmp4
                  pla
                  sta tmp3

                  lda tmp8
                  sec
                  sbc tmp7
                  sta tmp8
                  bpl @errpos

                  clc
                  lda tmp2
                  adc tmp4
                  sta tmp2

                  clc
                  lda tmp8
                  adc tmp6
                  sta tmp8

@errpos:
                  inc tmp1
                  jmp @steep
@done:
                  rts

; abs of a
abs:
                  and #$ff
                  bpl @found
                  eor #$ff
                  clc
                  adc #1  
@found:
                  rts
                  

; Drawn from $3C00
display:              
                  clc
                  clv   
                  lda #$00
                  sta R0
                  lda #$3C
                  sta R0 + 1

                  ldx #$0
                  ldy #$0

@next_page_group: lda #SSD1305_SETPAGESTART  ; even pages (0, 2, 4, 6)
                  stx R1
                  adc R1
                  sta SSD1305_COMMAND       ; Set Page
                  dc $00
                  dc $10

                  ; loop y < 128
@byte_loop1:      lda (R0), y
                  sta SSD1305_DATA
                  iny
                  bpl @byte_loop1
                  
                  ; odd pages (1, 3, 5, 7)
                  inx
                  lda #SSD1305_SETPAGESTART
                  stx R1
                  adc R1
                  sta SSD1305_COMMAND       ; Set Page
                  dc $00
                  dc $10
                  ; loop y < 256
@byte_loop2:      lda (R0), y
                  sta SSD1305_DATA
                  iny
                  bne @byte_loop2
                  inc R0 + 1                ; update pointer to the next block of 256
                  inx
                  stx R1
                  lda #8
                  bit R1
                  beq @next_page_group
                  rts

shift_table:               .byte 1, 2, 4, 8, 16, 32, 64, 128